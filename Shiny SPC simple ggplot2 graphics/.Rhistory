consumerSecret=consumer.Secret,
requestURL=reqURL,
accessURL=accessURL,
authURL=authURL)
twitCred$handshake()
reqURL <- "https://api.twitter.com/oauth/request_token"
accessURL <- "http://api.twitter.com/oauth/access_token"
authURL <- "http://api.twitter.com/oauth/authorize"
consumerKey <- "DOxfSOhS8421ErcmypUm2AmSw"
consumerSecret <- "OYhUiGFBMY6T5ILLgrKMZSL9A8b8TP5gc7MiDH7Q6VjdDpJdgl"
twitCred <- OAuthFactory$new(consumerKey=consumerKey,
consumerSecret=consumerSecret,
requestURL=reqURL,
accessURL=accessURL,
authURL=authURL)
twitCred$handshake()
getTwitterOAuth(consumerKey, consumerSecret)
getTwitterOAuth(consumerKey, consumerSecret)
library(twitteR)
library(ROAuth)
library(RCurl)
requestURL =   "https://api.twitter.com/oauth/request_token"
accessURL =    "https://api.twitter.com/oauth/access_token"
authURL =      "https://api.twitter.com/oauth/authorize"
consumerKey <- "DOxfSOhS8421ErcmypUm2AmSw"
consumerSecret <- "OYhUiGFBMY6T5ILLgrKMZSL9A8b8TP5gc7MiDH7Q6VjdDpJdgl"
twitCred <- OAuthFactory$new(consumerKey=consumerKey,
consumerSecret=consumerSecret,
requestURL=requestURL,
accessURL=accessURL,
authURL=authURL)
download.file(url="http://curl.haxx.se/ca/cacert.pem", destfile="cacert.pem")
twitCred$handshake(cainfo="cacert.pem")
save(list="twitCred", file="twitteR_credentials")
?save
getwd()
rate.limit <- getCurRateLimitInfo( cainfo="cacert.pem")
registerTwitterOAuth(twitCred)
rate.limit <- getCurRateLimitInfo()
rate.limit
the.text = "This is a test of Twitter using R"
the.user = "@crlong1775"
dmSend(the.text, user, ...)
dmSend(the.text, user)
dmSend(the.text, the.user)
the.text = "Hi @BartCapristo.  This is a test message sent using R with the twitteR package."
the.user = "@BartCapristo"
dmSend(the.text, the.user)
the.user = "@crlong1775"
dmSend(the.text, the.user)
the.user = "@BartCapristo"
dmSend(the.text, the.user)
the.user = "@crlong1775"
the.text = "Hi @BartCapristo 23.  This is a test message sent using R with the twitteR package."
dmSend(the.text, the.user)
the.text = "Hi @BartCapristo.  This is a test message sent using R with the twitteR package."
the.user = "@BartCapristo"
dmSend(the.text, the.user)
the.text = "Hi @BartCapristo.  This is a test message sent using R with the twitteR package."
the.user = "@crlong1775"
dmSend(the.text, the.user)
the.user = "@BartCapristo"
?dmSend
getFollowerIDs()
the.user = "@BartCapristo"
dmSend(the.text, the.user)
library(sendmailR)
d.to = "8475021595@txt.att.net"
from <- "CliffordLong@ussco.com"
subject <- "Email sent using R"
body <- "Email body.\n Open the pod bay doors, HAL.\n I'm sorry, Dave. I'm afraid I can't do that."
mailControl=list(smtpServer="ch2cas.ussco.com")
sendmail(from=from, to=d.to, subject=subject, msg=body, control=mailControl)
d.to = "6307303257@txt.att.net"  # Bart C.
sendmail(from=from, to=d.to, subject=subject, msg=body, control=mailControl)
d.to = "7703187539@vtext.com"  # Brian L.
sendmail(from=from, to=d.to, subject=subject, msg=body, control=mailControl)
library(xlsx)
?system.file
filename = "temporary SPC Metric Opt-In List.xlsm"
filepath = "http://sharepoint2/ops/quality/metricspc/Metric%20OptIn%20List/"
fileinfo = "http://sharepoint2/ops/quality/metricspc/Metric%20OptIn%20List/temporary%20SPC%20Metric%20Opt-In%20List.xlsm"
file <- system.file(filepath, filename, package = "xlsx")
file
res <- read.xlsx(file, 1) # read the first sheet
file <- system.file(fileinfo, package = "xlsx")
res <- read.xlsx(file, 1) # read the first sheet
file
system.file(fileinfo, package = "xlsx")
?file.exists
file.exists(fileinfo)
fileinfo = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
file.exists(fileinfo)
fileinfo = "C:\\Users\\longcli\\Dropbox\\Work USSCO\\Data for Analysis\\_06 DEPLOY Automated SPC monitor and alert\\Facility Opt-In\\temporary SPC Metric Opt-In List.xlsm"
file.exists(fileinfo)
library(RCurl)
x <- getURL(fileinfo)
fileinfo = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
x <- getURL(fileinfo)
res <- read.xlsx(x, 1) # read the first sheet
read.csv(text = x)
x
read.xlsx(text = x)
read.xlsx(text = x, 1)
?read.xlsx
read.xlsx(text = x, sheetName = sheetname)
sheetname = "OPT-IN LIST"
read.xlsx(text = x, sheetName = sheetname)
?getURL
fileinfo = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
read.xlsx(fileinfo, sheetName = "OPT-IN LIST")
getURL(fileinfo)
?url
conn <- url(description = fileinfo, open ="r");
conn
read.xlsx(fileinfo, sheetName = "OPT-IN LIST")
read.xlsx(file = conn, sheetName = "OPT-IN LIST")
read.xlsx(file = conn)
read.xlsx(file = conn, sheetName = "OPT-IN LIST")
?read.xlsx
conn <- url(description = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm",
open = "r")
dat <- read.xlsx(file = conn, sheetName = "OPT-IN LIST")
require(XLConnect)
wb = loadWorkbook(fileinfo)
wb = loadWorkbook(conn)
con <- odbcConnectExcel2007(url(fileinfo))
library(ROBDC)
install.packages("RODBC")
library(ROBDC)
library(ROBDC)
library(ROBDC)
library('ROBDC')
install.packages(c("aplpack", "arules", "BH", "car", "data.table", "deldir", "devtools", "digest", "effects", "forecast", "googleVis", "gplots", "gWidgets2tcltk", "highr", "Hmisc", "httpuv", "jsonlite", "knitr", "magrittr", "mime", "multcomp", "mvtnorm", "qcc", "questionr", "R.utils", "R6", "Rcmdr", "RColorBrewer", "Rcpp", "RcppArmadillo", "RCurl", "repmis", "reshape2", "rgl", "ROAuth", "RSQLite", "sendmailR", "shiny", "sparr", "spatstat", "sqldf", "testthat", "TH.data", "timeDate"))
require(XLConnect)
library(ROBDC)
library(ROBDC)
install.packages(c("aplpack", "car", "caTools", "digest", "doBy", "e1071", "effects", "forecast", "formatR", "Formula", "ggplot2", "gplots", "gtools", "highr", "Hmisc", "httpuv", "knitr", "labeling", "lme4", "markdown", "mgcv", "mime", "minqa", "multcomp", "mvtnorm", "plotrix", "psych", "qcc", "Rcmdr", "RColorBrewer", "Rcpp", "RcppArmadillo", "RcppEigen", "reshape2", "rgl", "RJSONIO", "sandwich", "sem", "shiny", "TH.data", "timeDate", "XLConnect", "xtable"))
library(ROBDC)
install.packages("RODBC")
library(ROBDC)
install.packages("ROBDC")
conn <- url(description = fileinfo, open ="r")
fileinfo = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
filename = "temporary SPC Metric Opt-In List.xlsm"
filepath = "http://sharepoint2/ops/quality/metricspc/Metric%20OptIn%20List/"
sheetname = "OPT-IN LIST"
conn <- url(description = fileinfo, open ="r")
conn
require(gdata)
df = read.xls(conn, sheet = 1, header = TRUE)
help(gdata)
df = read.xls(fileinfo, sheet = 1, header = TRUE)
nba.url <- "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
nba <- read.xls(nba.url)
nba <- read.xls(nba.url, perl = "perl")
nba.url
nba.path = "C:\\Users\\longcli\\Downloads\\temporary_SPC_Metric_Opt-In_List.xlsx"
nba <- read.xls(nba.path)
nba <- read.xls(nba.path, perl="perl")
nba <- read.xls(nba.path, sheet = "OPT-IN LIST", perl="perl")
nba.path = "C:\\Users\\longcli\\Downloads\\temporary_SPC_Metric_Opt-In_List.xlsx"
file.exists(nba.path)
wb = loadWorkbook(nba.path)
require(XLConnect)
wb = loadWorkbook(nba.path)
df = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE)
warnings()
nba.path = "C:\\Users\\longcli\\Downloads\\temporary_SPC_Metric_Opt-In_List.xlsm"
wb = loadWorkbook(nba.path)
df = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE)
warnings()
?readWorksheet
df = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE, useCachedValues = TRUE)
df
df2 = na.omit(df)
df2
df = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE, useCachedValues = TRUE, endCol = 1)
df
dim(df.init)
df.init = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE, useCachedValues = TRUE, endCol = 1)
dim(df.init)
df.all = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE,
useCachedValues = TRUE, endRow = dim(df.init)[1])
df.all
nba.path = "C:\\Users\\longcli\\Downloads\\temporary_SPC_Metric_Opt-In_List.xlsm"
file.exists(nba.path)
wb = loadWorkbook(nba.path)
optin.init = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE, endCol = 1)
optin.all = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE,
useCachedValues = TRUE, endRow = dim(optin.init)[1])
optin.init
optin.all
d.optin.init = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE, endCol = 1)
d.optin.all = readWorksheet(wb, sheet = "OPT-IN LIST", header = TRUE,
useCachedValues = TRUE, endRow = dim(optin.init)[1])
names(d.optin.all)
colnames(d.optin.all) <- c("FIRST.NAME",
"LAST.NAME",
"FACILITY",
"BUSINESS.UNIT",
"METRIC",
"EMAIL",
"MOBILE.PHONE",
"MOBILE.CARRIER")
names(d.optin.all)
nba.path = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
file.exists(nba.path)
library(gdata)
URL <- "http://www.econ.yale.edu/~shiller/data/ie_data.xls"
DF <- read.xls(URL, pattern = "Fraction")
DF <- read.xls(URL, pattern = "Fraction")
DF <- read.xls(URL, pattern = "Fraction", perl = "C:\\Perl64\\bin\\perl.exe")
DF
URL1 = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
DF1 <- read.xls(URL1, perl = "C:\\Perl64\\bin\\perl.exe")
DF1
head(DF1)
help(gdata)
gdata:::findPerl("perl")
DF1 <- read.xls(fileurl, pattern = "FIRST.NAME", perl = "C:\\Perl64\\bin\\perl.exe")
p
fileurl = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
DF1 <- read.xls(fileurl, pattern = "FIRST.NAME", perl = "C:\\Perl64\\bin\\perl.exe")
DF1
head(DF1)
?read.table
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE, perl = "C:\\Perl64\\bin\\perl.exe")
head(DF1)
head(DF1, 20)
help(gdata)
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE, perl = "C:\\Perl64\\bin\\perl.exe")[1]
head(DF1, 20)
DF1
na.omit(DF1)
tmp = na.omit(DF1)
tmp
head(DF1, 20)
nba
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE, na.strings = "(blank)",
perl = "C:\\Perl64\\bin\\perl.exe")[1]
head(DF1, 20)
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE, na.strings = "(blank)",
perl = "C:\\Perl64\\bin\\perl.exe")
head(DF1, 20)
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE, na.strings = "(blank)",
perl = "C:\\Perl64\\bin\\perl.exe")
head(DF1, 20)
tmp = DF1[,!("BUSINESS.UNIT" == "(blank)")]
head(tmp, 20)
tmp
head(tmp, 20)
DF1 <- read.xls(fileurl, blank.lines.skip = TRUE,
perl = "C:\\Perl64\\bin\\perl.exe")
head(tmp, 20)
fileurl = "http://sharepoint2/ops/quality/metricspc/Metric OptIn List/temporary SPC Metric Opt-In List.xlsm"
DF1 <- read.xls(fileurl, perl = "C:\\Perl64\\bin\\perl.exe")
head(DF1, 20)
tmp = DF1[,!("BUSINESS.UNIT" == "(blank)")]
head(tmp, 20)
tmp = DF1[,!(DF1$BUSINESS.UNIT == "(blank)")]
head(tmp, 20)
DF1$BUSINESS.UNIT
!(DF1$BUSINESS.UNIT == "(blank)")
DF1$BUSINESS.UNIT == "(blank)"
tmp = DF1[!(DF1$BUSINESS.UNIT == "(blank)"),]
head(tmp, 20)
d.optin.init <- read.xls(fileurl, perl = "C:\\Perl64\\bin\\perl.exe")
d.optin = DF1[!(DF1$BUSINESS.UNIT == "(blank)"),]
d.optin
colnames(d.optin) <- c("FIRST.NAME",
"LAST.NAME",
"FACILITY",
"BUSINESS.UNIT",
"METRIC",
"EMAIL",
"MOBILE.PHONE",
"MOBILE.CARRIER")
d.optin
install.packages("manipulate")
setwd("~/GitHub/Shiny-Simple-SPC-ggplot2_graphics/Shiny SPC simple ggplot2 graphics")
library(shiny)
library(reshape2)
library(qcc)
library(plyr)
library(chron)
library(ggplot2)
library(gridExtra)
library(scales)
wd.datapath = paste0(getwd(),"/data")
wd.init = getwd()
setwd(wd.datapath)
d.in = read.table("data by bu fac metric.txt", sep = '\t', header = TRUE)
setwd(wd.init)
# convert year and month into date
d.in$date = as.Date(ISOdate(d.in$year, d.in$monthnum, 1))
strata.bu = "busunit_1"
strata.facility = "facility_701"
d.strata = subset(d.in, d.in$business == strata.bu & d.in$facility == strata.facility)
d.strata = droplevels(d.strata)
d.strata = d.strata[order(d.strata$date, decreasing = FALSE),]
strata.metric = "Metric 1"
if (strata.metric == "Metric 1") {qccvar = "metric_1"}
if (strata.metric == "Metric 2") {qccvar = "metric_2"}
if (strata.metric == "Metric 3") {qccvar = "metric_3"}
qccvar
# TEMPORARY ALTERNATIVE #2
baseline.window.begin.date = as.Date("2014-04-01")
baseline.window.end.date = as.Date("2014-10-31")
sub.limit.dat = subset(d.strata, date >= baseline.window.begin.date & date <= baseline.window.end.date)
# NOTE - using only six periods for an SPC chart is not usually recommended
# We take this approach in this code only to show how to use a subset of the
# data to get SPC limits that are then applied to the larger set of data.
# used to calculate SPC limits based on subset
qcc.limits = qcc(sub.limit.dat[,qccvar],
type = 'xbar.one',
plot = TRUE,
labels = sub.limit.dat$date)  # kept labels in case needed to display graph
qcc.limits
qcc.chart = suppressWarnings( qcc( d.strata[,qccvar],
type = 'xbar.one',
plot = TRUE,
center = qcc.limits$center,
labels = d.strata$date)  # end qcc
)  # end supressWarnings
# prune the data for spc charting (dates, values)
spc.data <- data.frame(x = factor(d.strata$date), y = d.strata[,qccvar])
# used for convenient formatting of x-axis in SPC chart
spc.data$xdate = as.Date(spc.data$x)
# THE CODE FOR THE FANCY SPC CHART --------------------------------------
q.center = qcc.limits$center
q.limits = qcc.limits$limits
v.limits = qcc.chart$violations$beyond.limits
v.runs = qcc.chart$violations$violating.runs
# library(ggplot2)
# continuing with creating the plot
p.size = 4    # controls point size in plot
# the main plot
spc.ggplot <- ggplot(spc.data, aes(x = xdate, y = y)) +
geom_line(aes(x = xdate, y = y)) +                              # adds lines between points
geom_point(shape = 20, size = (p.size*1.7), color="white") +    # space between dots and lines
geom_point(shape = 20, size = p.size) +                         # adds the dots
scale_x_date(breaks = "3 months") +                              # uses subset of dates on x-axis
scale_y_continuous(labels = percent) +                          # formats y-tick labels as pct
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +    # rotates axis text
theme(axis.title.x = element_blank()) +                         # suppress x-axis label
ylab("Percent")
# adds horizontal lines for SPC control chart limits
spc.ggplot <- spc.ggplot +
geom_hline(yintercept = q.center, linetype = "dotted") +     # adds center line
geom_hline(yintercept = q.limits[1], linetype = "dashed") +  # adds LCL
geom_hline(yintercept = q.limits[2], linetype = "dashed")    # adds UCL
# identify runs-rules violations with orange point
v.runs.subdata <- spc.data[v.runs,]
spc.ggplot <- spc.ggplot +
geom_point(data = v.runs.subdata, aes(x = xdate, y = y), size = p.size, col = "orange")
# identify limits violations with red point
v.limits.subdata <- spc.data[v.limits,]
spc.ggplot <- spc.ggplot +
geom_point(data = v.limits.subdata, aes(x = xdate, y = y), size = p.size, col = "red")
spc.ggplot
qcc.limits
# Individuals (X) chart
qcc.chart = suppressWarnings( qcc( d.strata[,qccvar],
type = 'xbar.one',
plot = TRUE,
center = qcc.limits$center,
labels = d.strata$date)  # end qcc
)  # end supressWarnings
q.limits
qcc.limits = qcc(sub.limit.dat[,qccvar],
type = 'xbar.one',
plot = FALSE,
labels = sub.limit.dat$date)  # kept labels in case needed to display graph
# Individuals (X) chart
qcc.chart = suppressWarnings( qcc( d.strata[,qccvar],
type = 'xbar.one',
plot = TRUE,
center = qcc.limits$center,
limits = qcc.limits$limits,
labels = d.strata$date)  # end qcc
)  # end supressWarnings
q.center = qcc.limits$center
q.limits = qcc.limits$limits
v.limits = qcc.chart$violations$beyond.limits
v.runs = qcc.chart$violations$violating.runs
# TEMPORARY ALTERNATIVE #2
baseline.window.begin.date = as.Date("2014-11-01")
baseline.window.end.date = as.Date("2014-10-31")
sub.limit.dat = subset(d.strata, date >= baseline.window.begin.date & date <= baseline.window.end.date)
# NOTE - using only six periods for an SPC chart is not usually recommended
# We take this approach in this code only to show how to use a subset of the
# data to get SPC limits that are then applied to the larger set of data.
# used to calculate SPC limits based on subset
qcc.limits = qcc(sub.limit.dat[,qccvar],
type = 'xbar.one',
plot = FALSE,
labels = sub.limit.dat$date)  # kept labels in case needed to display graph
# CREATE SPC CHART
##    # ORIGINAL SPC CODE
##    x.chart = qcc( d.strata[,qccvar], type = "xbar.one", labels = d.strata[,'yearmon'],
##                  title = paste("Individuals chart\n", input$in.facility, qccvar) )
# MODIFIED SPC CODE - uses precalculated SPC control chart limits based on defined range above
# Individuals (X) chart
qcc.chart = suppressWarnings( qcc( d.strata[,qccvar],
type = 'xbar.one',
plot = TRUE,
center = qcc.limits$center,
limits = qcc.limits$limits,
labels = d.strata$date)  # end qcc
)  # end supressWarnings
sub.limit.dat
# TEMPORARY ALTERNATIVE #2
baseline.window.begin.date = as.Date("2013-11-01")
baseline.window.end.date = as.Date("2014-10-31")
sub.limit.dat = subset(d.strata, date >= baseline.window.begin.date & date <= baseline.window.end.date)
# NOTE - using only six periods for an SPC chart is not usually recommended
# We take this approach in this code only to show how to use a subset of the
# data to get SPC limits that are then applied to the larger set of data.
# used to calculate SPC limits based on subset
qcc.limits = qcc(sub.limit.dat[,qccvar],
type = 'xbar.one',
plot = FALSE,
labels = sub.limit.dat$date)  # kept labels in case needed to display graph
# CREATE SPC CHART
##    # ORIGINAL SPC CODE
##    x.chart = qcc( d.strata[,qccvar], type = "xbar.one", labels = d.strata[,'yearmon'],
##                  title = paste("Individuals chart\n", input$in.facility, qccvar) )
# MODIFIED SPC CODE - uses precalculated SPC control chart limits based on defined range above
# Individuals (X) chart
qcc.chart = suppressWarnings( qcc( d.strata[,qccvar],
type = 'xbar.one',
plot = TRUE,
center = qcc.limits$center,
limits = qcc.limits$limits,
labels = d.strata$date)  # end qcc
)  # end supressWarnings
spc.data <- data.frame(x = factor(d.strata$date), y = d.strata[,qccvar])
spc.data$xdate = as.Date(spc.data$x)
q.center = qcc.limits$center
q.limits = qcc.limits$limits
v.limits = qcc.chart$violations$beyond.limits
v.runs = qcc.chart$violations$violating.runs
p.size = 4    # controls point size in plot
# the main plot
spc.ggplot <- ggplot(spc.data, aes(x = xdate, y = y)) +
geom_line(aes(x = xdate, y = y)) +                              # adds lines between points
geom_point(shape = 20, size = (p.size*1.7), color="white") +    # space between dots and lines
geom_point(shape = 20, size = p.size) +                         # adds the dots
scale_x_date(breaks = "3 months") +                              # uses subset of dates on x-axis
scale_y_continuous(labels = percent) +                          # formats y-tick labels as pct
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +    # rotates axis text
theme(axis.title.x = element_blank()) +                         # suppress x-axis label
ylab("Percent")
# adds horizontal lines for SPC control chart limits
spc.ggplot <- spc.ggplot +
geom_hline(yintercept = q.center, linetype = "dotted") +     # adds center line
geom_hline(yintercept = q.limits[1], linetype = "dashed") +  # adds LCL
geom_hline(yintercept = q.limits[2], linetype = "dashed")    # adds UCL
# identify runs-rules violations with orange point
v.runs.subdata <- spc.data[v.runs,]
spc.ggplot <- spc.ggplot +
geom_point(data = v.runs.subdata, aes(x = xdate, y = y), size = p.size, col = "orange")
# identify limits violations with red point
v.limits.subdata <- spc.data[v.limits,]
spc.ggplot <- spc.ggplot +
geom_point(data = v.limits.subdata, aes(x = xdate, y = y), size = p.size, col = "red")
spc.ggplot
title.text = paste("Individuals SPC Chart for ",
strata.facility,
#qcctext,
"\nData through week of",
max(spc.data$xdate),
"\nLimits calculated between",
min(sub.limit.dat$date),
"and",
max(sub.limit.dat$date) )
spc.ggplot <- spc.ggplot + ggtitle(title.text)
spc.ggplot
x.labels = levels(spc.data$x) # used in a hack to get plots to align
dens.left <-  ggplot(spc.data) + geom_density(aes(y), fill = 'darkgray') +
scale_y_discrete(breaks = 1, labels = x.labels[1]) +
coord_flip() +                                                # rotates the plot
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +    # rotates axis text
theme(axis.text.x = element_text(color="white")) +            # see note A
theme(axis.title.x = element_blank()) +                       # suppresses x-axis title
theme(axis.ticks = element_blank()) +                         # suppresses tick marks
theme(axis.title.y = element_blank())                         # suppresses y-axis title
dens.left <- dens.left +
ggtitle(title.text) +
theme(plot.title = element_text(color = "white"))             # a hack to get plot tops to align
dens.left
spc.ylim = ggplot_build(spc.ggplot)$panel$ranges[[1]]$y.range
spc.ymaj = ggplot_build(spc.ggplot)$panel$ranges[[1]]$y.major_source
p1.common.y <- spc.ggplot + scale_y_continuous(limits = spc.ylim, breaks = spc.ymaj, labels = percent)
p2.common.y <- dens.left + scale_x_continuous(limits = spc.ylim, breaks = spc.ymaj, labels = percent)
# build the plots
p1.common.y <- ggplot_gtable(ggplot_build(p1.common.y))
p2.common.y <- ggplot_gtable(ggplot_build(p2.common.y))
# copy the plot height from p1 to p2
p2.common.y$heights <- p1.common.y$heights
# another method - uses gridExtra
# library(gridExtra)
# using print seems to overcome a difficulty when using Shiny with grid.arrange
print( grid.arrange(arrangeGrob(p2.common.y, p1.common.y, ncol=2,
widths=c(1,4)), heights=c(1,1)) )
setwd("~/GitHub/Shiny-Simple-SPC-ggplot2_graphics/Shiny SPC simple ggplot2 graphics")
runApp()
runApp()
runApp()
runApp()
runApp()
